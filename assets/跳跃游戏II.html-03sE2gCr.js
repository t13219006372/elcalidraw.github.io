import{_ as s,o as n,c as a,f as l}from"./app-tN7dId5R.js";const e="/assets/image-4-CGZ6COaG.png",p="/assets/image-5-C8uYgDw6.png",o={},t=l(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目"><span>题目</span></a></h2><p>给定一个长度为 n 的 <strong>0 索引</strong>整数数组 nums。初始位置为 nums[0]。</p><p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p><ul><li>0 &lt;= j &lt;= nums[i]</li><li>i + j &lt; n</li></ul><p>返回到达 nums[n - 1] 的<strong>最小跳跃次数</strong>。生成的测试用例可以到达 nums[n - 1]。</p><p><strong>示例 1：</strong></p><blockquote><p>输入: nums = [2,3,1,1,4]<br> 输出: 2<br> 解释: 跳到最后一个位置的最小跳跃数是 2。<br> 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入: nums = [2,3,0,1,4]<br> 输出: 2</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^4^</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h2 id="解法" tabindex="-1"><a class="header-anchor" href="#解法"><span>解法</span></a></h2><h3 id="_1-暴力枚举" tabindex="-1"><a class="header-anchor" href="#_1-暴力枚举"><span>1. 暴力枚举</span></a></h3><h4 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h4><div class="hint-container tip"><p class="hint-container-title">提示</p><p>由于一定能跳跃到最后<code>nums[n-1]</code>处。所以我们可以通过判断 <strong>能跳到指定位置的最远位置</strong>,直到这个最远位置为<strong>0</strong>，所用的次数即为最小次数。</p><p>例如:<br> nums = [2,3,1,1,4]<br> 要判断能到达 4(index == 4)的位置为 3（index == 1）、1（index == 3）,其中最远位置为 3（index == 1）。<br> 接着判断能到达 3（index == 3）的位置为 2（index == 0），即使用次数为 2 次。</p></div><h4 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h4><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">  func</span><span style="color:#61AFEF;"> jump</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">nums</span><span style="color:#ABB2BF;"> []</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 当前位置为最后一位</span></span>
<span class="line"><span style="color:#E06C75;">    position</span><span style="color:#E5C07B;"> :=</span><span style="color:#61AFEF;"> len</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">nums</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">-</span><span style="color:#D19A66;"> 1</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 需要跳的次数</span></span>
<span class="line"><span style="color:#E06C75;">    steps</span><span style="color:#E5C07B;"> :=</span><span style="color:#D19A66;"> 0</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 当这个位置为0时停止</span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#E06C75;"> position</span><span style="color:#56B6C2;"> &gt;</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">        for</span><span style="color:#E06C75;"> i</span><span style="color:#E5C07B;"> :=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;"> &lt;</span><span style="color:#E06C75;"> position</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            // 从数组最开始循环，第一个能到达这个位置的位置即为最远位置</span></span>
<span class="line"><span style="color:#C678DD;">            if</span><span style="color:#E06C75;"> i</span><span style="color:#C678DD;"> +</span><span style="color:#E06C75;"> nums</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#E06C75;"> position</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 更改最远位置</span></span>
<span class="line"><span style="color:#E06C75;">                position</span><span style="color:#E5C07B;"> =</span><span style="color:#E06C75;"> i</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">                // 跳跃次数+1</span></span>
<span class="line"><span style="color:#E06C75;">                steps</span><span style="color:#56B6C2;">++</span></span>
<span class="line"><span style="color:#C678DD;">                break</span></span>
<span class="line"><span style="color:#ABB2BF;">            }</span></span>
<span class="line"><span style="color:#ABB2BF;">        }</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#E06C75;"> steps</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="测试用例" tabindex="-1"><a class="header-anchor" href="#测试用例"><span>测试用例</span></a></h4><figure><img src="`+e+`" alt="暴力枚举测试用例" tabindex="0" loading="lazy"><figcaption>暴力枚举测试用例</figcaption></figure><h4 id="分析" tabindex="-1"><a class="header-anchor" href="#分析"><span>分析</span></a></h4><ul><li><p>时间复杂度 <strong>O(n<sup>2</sup>)</strong>：因为使用了双重循环，所以时间复杂度为 <strong>O(n<sup>2</sup>)</strong></p></li><li><p>空间复杂度 <strong>O(1)</strong>: 因为所有的变量都是常数级别的，因为空间复杂度为 <strong>O(1)</strong>。</p></li></ul><h3 id="_2-贪心算法" tabindex="-1"><a class="header-anchor" href="#_2-贪心算法"><span>2.贪心算法</span></a></h3><h4 id="解题思路-1" tabindex="-1"><a class="header-anchor" href="#解题思路-1"><span>解题思路</span></a></h4><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当前位置能跳到的最远位置为<strong>k = nums[index]+index</strong>, 但随着起跳点的变动，这个 k 也会随之变动；我们定义另外一个变量 <code>next</code> 来保存当前这段起跳的终点，当起跳点在 <strong><code>(index，next]</code></strong> 这个区间时，为下一次跳跃, 即当 **<code>index == next+1</code>**时为下一次跳跃。当有一个位置能跳跃到最后位置时结束。<br><strong>需要考虑特殊条件，当<code>len(nums) == 1</code>时，不用跳跃</strong></p><p>例如:<br> nums = [2,3,1,1,4,7,7]<br> 第一次起跳 2（index == 0）。最大跳跃位置为 1（index == 2）。<br> 第二次跳跃的起点区间为[3,1]（index为[1,2]），最大跳跃位置为 4 (index == 4)。<br> 第三次跳跃的起点区间为[1,4]（index为[3,4]）,最大跳跃位置 index == 8，超过数组最后一位的下标，即能直接跳跃到终点。</p></div><h4 id="代码示例-1" tabindex="-1"><a class="header-anchor" href="#代码示例-1"><span>代码示例</span></a></h4><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">  import</span><span style="color:#98C379;"> &quot;math&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">  func</span><span style="color:#61AFEF;"> jump</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">nums</span><span style="color:#ABB2BF;"> []</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">	  k</span><span style="color:#E5C07B;"> :=</span><span style="color:#D19A66;"> 0</span></span>
<span class="line"><span style="color:#E06C75;">	  n</span><span style="color:#E5C07B;"> :=</span><span style="color:#61AFEF;"> len</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">nums</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#E06C75;">	  count</span><span style="color:#E5C07B;"> :=</span><span style="color:#D19A66;"> 1</span></span>
<span class="line"><span style="color:#E06C75;">	  next</span><span style="color:#E5C07B;"> :=</span><span style="color:#D19A66;"> 0</span></span>
<span class="line"><span style="color:#C678DD;">	  if</span><span style="color:#E06C75;"> n</span><span style="color:#56B6C2;"> ==</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">		  return</span><span style="color:#D19A66;"> 0</span></span>
<span class="line"><span style="color:#ABB2BF;">	  }</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">	  for</span><span style="color:#E06C75;"> index</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">num</span><span style="color:#E5C07B;"> :=</span><span style="color:#C678DD;"> range</span><span style="color:#E06C75;"> nums</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">      // 当起跳点超过这次起跳段的终点时即视为下一次起跳</span></span>
<span class="line"><span style="color:#C678DD;">      if</span><span style="color:#E06C75;"> index</span><span style="color:#56B6C2;"> ==</span><span style="color:#E06C75;"> next</span><span style="color:#C678DD;"> +</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 将下一次的起跳段的终点设置为能跳到的最远距离</span></span>
<span class="line"><span style="color:#E06C75;">			  next</span><span style="color:#E5C07B;"> =</span><span style="color:#E06C75;"> k</span></span>
<span class="line"><span style="color:#E06C75;">			  count</span><span style="color:#56B6C2;">++</span></span>
<span class="line"><span style="color:#ABB2BF;">		  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">      // 当能跳跃到重点时结束</span></span>
<span class="line"><span style="color:#C678DD;">		  if</span><span style="color:#E06C75;"> index</span><span style="color:#C678DD;">+</span><span style="color:#E06C75;">num</span><span style="color:#56B6C2;"> &gt;=</span><span style="color:#E06C75;"> n</span><span style="color:#C678DD;">-</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">			  return</span><span style="color:#E06C75;"> count</span></span>
<span class="line"><span style="color:#ABB2BF;">		  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">      // 实时计算最大位置k</span></span>
<span class="line"><span style="color:#E06C75;">      k</span><span style="color:#E5C07B;"> =</span><span style="color:#C678DD;"> int</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">math</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">Max</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">float64</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">k</span><span style="color:#ABB2BF;">), </span><span style="color:#C678DD;">float64</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">index</span><span style="color:#C678DD;">+</span><span style="color:#E06C75;">num</span><span style="color:#ABB2BF;">)))</span></span>
<span class="line"><span style="color:#ABB2BF;">	  } </span></span>
<span class="line"><span style="color:#C678DD;">	  return</span><span style="color:#E06C75;"> count</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="测试用例-1" tabindex="-1"><a class="header-anchor" href="#测试用例-1"><span>测试用例</span></a></h4><figure><img src="`+p+'" alt="贪心算法测试用例" tabindex="0" loading="lazy"><figcaption>贪心算法测试用例</figcaption></figure><h4 id="分析-1" tabindex="-1"><a class="header-anchor" href="#分析-1"><span>分析</span></a></h4><ul><li>时间复杂度 <strong>O(n)</strong>: 因为只遍历了一遍数组，所以时间复杂度为 <strong>O(n)</strong></li><li>空间复杂度 <strong>O(1)</strong>：因为该函数只使用了常量级别的额外空间, 所以空间复杂度为 <strong>O(1)</strong>。</li></ul>',30),i=[t];function c(r,d){return n(),a("div",null,i)}const u=s(o,[["render",c],["__file","跳跃游戏II.html.vue"]]),B=JSON.parse(`{"path":"/leetcode/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html","title":"跳跃游戏II","lang":"zh-CN","frontmatter":{"title":"跳跃游戏II","description":"算法，数组，跳跃游戏II，golang","date":"2024-04-12 21:32:00","star":true,"isOriginal":true,"category":["算法"],"tag":["算法"],"head":[["meta",{"property":"og:url","content":"https://blog.singlequote.cn/leetcode/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html"}],["meta",{"property":"og:site_name","content":"SingleQuote's Blog"}],["meta",{"property":"og:title","content":"跳跃游戏II"}],["meta",{"property":"og:description","content":"算法，数组，跳跃游戏II，golang"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T19:56:06.000Z"}],["meta",{"property":"article:author","content":"SingleQuote"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-04-12T13:32:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T19:56:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"跳跃游戏II\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-12T13:32:00.000Z\\",\\"dateModified\\":\\"2024-04-12T19:56:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"SingleQuote\\",\\"url\\":\\"blog.SingleQuote.cn\\"}]}"]]},"headers":[{"level":2,"title":"题目","slug":"题目","link":"#题目","children":[]},{"level":2,"title":"解法","slug":"解法","link":"#解法","children":[{"level":3,"title":"1. 暴力枚举","slug":"_1-暴力枚举","link":"#_1-暴力枚举","children":[]},{"level":3,"title":"2.贪心算法","slug":"_2-贪心算法","link":"#_2-贪心算法","children":[]}]}],"git":{"createdTime":1712951766000,"updatedTime":1712951766000,"contributors":[{"name":"tmh","email":"t13219006372@163.com","commits":1}]},"readingTime":{"minutes":3.28,"words":985},"filePathRelative":"leetcode/跳跃游戏II.md","localizedDate":"2024年4月12日","excerpt":"<h2>题目</h2>\\n<p>给定一个长度为 n 的 <strong>0 索引</strong>整数数组 nums。初始位置为 nums[0]。</p>\\n<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>\\n<ul>\\n<li>0 &lt;= j &lt;= nums[i]</li>\\n<li>i + j &lt; n</li>\\n</ul>\\n<p>返回到达 nums[n - 1] 的<strong>最小跳跃次数</strong>。生成的测试用例可以到达 nums[n - 1]。</p>\\n<p><strong>示例 1：</strong></p>"}`);export{u as comp,B as data};
