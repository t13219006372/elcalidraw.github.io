import{_ as e,o as a,c as s,f as t}from"./app-tN7dId5R.js";const n="/assets/image-1-D1_-vyT1.png",o="/assets/image-2-CogNfUXF.png",r="/assets/image-3-r9GkoJyi.png",l="/assets/image-4-CDva1Sdq.png",c="/assets/image-5-CgZE9yag.png",d={},i=t('<h2 id="什么是-dockerfile" tabindex="-1"><a class="header-anchor" href="#什么是-dockerfile"><span>什么是 Dockerfile</span></a></h2><p><strong>Dockerfile</strong>是一个用于描述 Docker 镜像构建过程的文本文件，这个文件可以包含多条构建指令以及相关的描述。用户可以自定义 <strong>Dockerfile</strong>构建自己的 docker 镜像。</p><h2 id="docker-镜像的构建原理" tabindex="-1"><a class="header-anchor" href="#docker-镜像的构建原理"><span>Docker 镜像的构建原理</span></a></h2><h3 id="docker-架构模型" tabindex="-1"><a class="header-anchor" href="#docker-架构模型"><span>Docker 架构模型</span></a></h3><p>Docker 采用的是<strong>C/S</strong>架构。在客户端使用输入构建命令时，Docker 引擎将命令发送到<strong>docker daemon</strong>，docker daemon 就根据请求内容，开始构建工作，并向 Client 持续返回构建过程信息，让用户可以看到当前的构建状态。</p><h3 id="镜像分层模型" tabindex="-1"><a class="header-anchor" href="#镜像分层模型"><span>镜像分层模型</span></a></h3><p>Docker 镜像是用于创建容器的<strong>只读模板</strong>。是由 <code>Dockerfile</code> 中定义的指令构建而成。在构建完成时。将会在原有的镜像上生成一个新的镜像层(由很多个 layer 层组成，<strong>Dockerfile</strong>中一行指令即生成一个 layer 层)。</p><figure><img src="'+n+'" alt="docker 镜像分层模型" tabindex="0" loading="lazy"><figcaption>docker 镜像分层模型</figcaption></figure><p>使用 <code>docker history node-hello-world:latest</code> 或 <code>docker inspect node-hello-world:latest</code> 即可查看<code>node-hello-world:latest</code>镜像分层。</p><figure><img src="'+o+'" alt="使用docker history命令查看镜像分层" tabindex="0" loading="lazy"><figcaption>使用docker history命令查看镜像分层</figcaption></figure><p>其中每一条内容即为<strong>Dockerfile 中每条指令</strong>生成的 layer 层, 配合<code>docker inspect node-hello-world:latest</code> 查看生成的 layer 层信息。</p><figure><img src="'+r+`" alt="使用docker inspect命令查看生成layer层信息" tabindex="0" loading="lazy"><figcaption>使用docker inspect命令查看生成layer层信息</figcaption></figure><h3 id="构建上下文" tabindex="-1"><a class="header-anchor" href="#构建上下文"><span>构建上下文</span></a></h3><p>Client 向 Docker daemon 发送构建命令分为两个部分内容，一部分就是最重要的 <strong>Dockerfile</strong> 文件。另一部分就是构建上下文。</p><p>构建上下文是一些文件的集合。这些文件可以是指定路径下的文件，也可以是远程资源中指定路径下的文件。<br> 构建过程中，Docker daemon 可以访问这些文件，并执行相应操作。</p><p>构建上下文可以分为以下 3 中情况。</p><h4 id="路径上下文" tabindex="-1"><a class="header-anchor" href="#路径上下文"><span>路径上下文</span></a></h4><p>构建命令中指定的具体路径，这个路径下面的所有文件组成的集合即为构建上下文。这些文件将会被打包发送到 Docker daemon 中，然后被解压。</p><p>假设一个项目的文件结构如下:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">demo</span></span>
<span class="line"><span style="color:#ABB2BF;">|</span><span style="color:#61AFEF;">--</span><span style="color:#98C379;"> Dockerfile</span></span>
<span class="line"><span style="color:#ABB2BF;">|</span><span style="color:#61AFEF;">--</span><span style="color:#98C379;"> src</span></span>
<span class="line"><span style="color:#ABB2BF;">|</span><span style="color:#61AFEF;">--</span><span style="color:#98C379;"> node_modules</span></span>
<span class="line"><span style="color:#ABB2BF;">|</span><span style="color:#61AFEF;">--</span><span style="color:#98C379;"> test</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 demo 文件夹下执行如下构建命令:</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">docker</span><span style="color:#98C379;"> build</span><span style="color:#D19A66;"> -t</span><span style="color:#98C379;"> test:v1</span><span style="color:#98C379;"> .</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构建请求的第一部分为 Dockerfile，这个文件在当前文件夹下，文件名是默认名称，可以省略。<br> 构建的第二部分内容为构建上下文，在构建命令中 <code>.</code> 代表将当前目录作为构建上下文，即 demo 文件夹下所有文件组成的集合成为构建上下文。<br> Docker 引擎会把不被 <strong>.dockerignore</strong> 中规则匹配的文件都发送到 Docker daemon。并执行 Dockerfile 中的指令。</p><h4 id="url-上下文" tabindex="-1"><a class="header-anchor" href="#url-上下文"><span>URL 上下文</span></a></h4><p>Docker 还支持利用远程仓库 URL 构建镜像，此时指定远程仓库目录充当构建上下文</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">    docker</span><span style="color:#98C379;"> build</span><span style="color:#98C379;"> http://gitee.com:user/my-repo.git#master:docker</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上构建命令指定了一个 Gitee 项目的 master 分支，冒号 <em>:</em> 之前是 Git 检出的目标 URL，冒号之后的 docker 是远程仓库根目录下的一个子目录，此时这个名为 docker 的子目录就是构建上下文。</p><h4 id="省略上下文" tabindex="-1"><a class="header-anchor" href="#省略上下文"><span>省略上下文</span></a></h4><p>如果 Dockerfile 中的指令不需要对任何文件进行操作，可以省略上下文，此时不会向 Docker daemon 发送额外文件，这可以提高构建速度。</p><p>示例构建命令如下</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">    docker</span><span style="color:#98C379;"> build</span><span style="color:#D19A66;"> -t</span><span style="color:#98C379;"> test:v1</span><span style="color:#98C379;"> -</span><span style="color:#ABB2BF;">&lt;&lt; </span><span style="color:#ABB2BF;">EOF</span></span>
<span class="line"><span style="color:#98C379;">    FROM scratch</span></span>
<span class="line"><span style="color:#98C379;">    RUN echo &quot;hello world&quot;</span></span>
<span class="line"><span style="color:#98C379;">    EOF</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="构建缓存" tabindex="-1"><a class="header-anchor" href="#构建缓存"><span>构建缓存</span></a></h3><p>迭代过程中，Dockerfile 对应的资源会经常修改，因此需要频繁重新构建镜像，Docker 为了提高构建速度，设计了多种优化方案，其中最重要的就是构建缓存。</p><p>下面会通过一个示例来说明构建缓存是如何工作的，Dockerfile 如下</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;color:#abb2bf;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">    FROM</span><span style="color:#98C379;"> node:16</span></span>
<span class="line"><span style="color:#61AFEF;">    ADD</span><span style="color:#98C379;"> app.js</span><span style="color:#98C379;"> /app/app.js</span></span>
<span class="line"><span style="color:#61AFEF;">    WORKDIR</span><span style="color:#98C379;"> /app/</span></span>
<span class="line"><span style="color:#61AFEF;">    CMD</span><span style="color:#98C379;"> node</span><span style="color:#98C379;"> app.js</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构建过程中，Dockerfile中指令会从上往下执行，每个构建步骤的结果会被缓存起来，如下图</p><figure><img src="`+l+'" alt="构建缓存示例" tabindex="0" loading="lazy"><figcaption>构建缓存示例</figcaption></figure><p>再次构建会使用缓存中的值。如果文件有修改，那么使用这个文件的上层所有缓存失效。如修改 <code>app.js</code></p><figure><img src="'+c+'" alt="构建缓存失效" tabindex="0" loading="lazy"><figcaption>构建缓存失效</figcaption></figure><p>如果不想使用构建缓存可以使用 <code>--no-cache</code> 选项实现。</p><h2 id="常用构建构建指令" tabindex="-1"><a class="header-anchor" href="#常用构建构建指令"><span>常用构建构建指令</span></a></h2><table><thead><tr><th>序号</th><th>指令</th><th>名功能描述</th></tr></thead><tbody><tr><td>1</td><td>FROM</td><td>指定基础镜像或父级镜像</td></tr><tr><td>2</td><td>LABEL</td><td>为镜像添加元数据3ENV设置环境变量</td></tr><tr><td>4</td><td>WORKDIR</td><td>指定后续指令的工作目录，类似于 Linux 中的 cd 命令</td></tr><tr><td>5</td><td>USER</td><td>指定当前构建阶段以及容器运行时的默认用户，以及可选的用户组</td></tr><tr><td>6</td><td>VOLUME</td><td>创建具有指定名称的挂载数据卷，用于数据持久化</td></tr><tr><td>7</td><td>ADD</td><td>将构建上下文中指定目录下的文件复制到镜像文件系统的指定位置</td></tr><tr><td>8</td><td>COPY</td><td>功能和语法与 ADD 类似，但是不会自动解压文件，也不能访问网络资源</td></tr><tr><td>9</td><td>EXPOSE</td><td>约定容器运行时监听的端口，通常用于容器与外界之间的通信</td></tr><tr><td>10</td><td>RUN</td><td>用于在构建镜像过程中执行命令</td></tr><tr><td>11</td><td>CMD</td><td>构建镜像成功后，所创建的容器启动时执行的命令，常与 ENTRYPOINT 结合使用</td></tr><tr><td>12</td><td>ENTRYPOINT</td><td>用于配置容器以可执行的方式运行，常与 CMD 结合使用</td></tr></tbody></table>',42),p=[i];function h(g,k){return a(),s("div",null,p)}const u=e(d,[["render",h],["__file","docker-file.html.vue"]]),b=JSON.parse(`{"path":"/server/docker/docker-file.html","title":"Dockerfile详解","lang":"zh-CN","frontmatter":{"title":"Dockerfile详解","description":"Docker,docker，容器，服务器，Dockerfile详解","date":"2024-04-16T10:46:00.000Z","icon":"dockerfile","cover":"https://w.wallhaven.cc/full/5g/wallhaven-5g8r11.jpg","star":true,"isOriginal":true,"category":["Docker"],"tag":["Docker"],"order":5,"head":[["meta",{"property":"og:url","content":"https://blog.singlequote.cn/server/docker/docker-file.html"}],["meta",{"property":"og:site_name","content":"SingleQuote's Blog"}],["meta",{"property":"og:title","content":"Dockerfile详解"}],["meta",{"property":"og:description","content":"Docker,docker，容器，服务器，Dockerfile详解"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://w.wallhaven.cc/full/5g/wallhaven-5g8r11.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-17T09:46:55.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Dockerfile详解"}],["meta",{"property":"article:author","content":"SingleQuote"}],["meta",{"property":"article:tag","content":"Docker"}],["meta",{"property":"article:published_time","content":"2024-04-16T10:46:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-17T09:46:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dockerfile详解\\",\\"image\\":[\\"https://w.wallhaven.cc/full/5g/wallhaven-5g8r11.jpg\\"],\\"datePublished\\":\\"2024-04-16T10:46:00.000Z\\",\\"dateModified\\":\\"2024-04-17T09:46:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"SingleQuote\\",\\"url\\":\\"blog.SingleQuote.cn\\"}]}"]]},"headers":[{"level":2,"title":"什么是 Dockerfile","slug":"什么是-dockerfile","link":"#什么是-dockerfile","children":[]},{"level":2,"title":"Docker 镜像的构建原理","slug":"docker-镜像的构建原理","link":"#docker-镜像的构建原理","children":[{"level":3,"title":"Docker 架构模型","slug":"docker-架构模型","link":"#docker-架构模型","children":[]},{"level":3,"title":"镜像分层模型","slug":"镜像分层模型","link":"#镜像分层模型","children":[]},{"level":3,"title":"构建上下文","slug":"构建上下文","link":"#构建上下文","children":[]},{"level":3,"title":"构建缓存","slug":"构建缓存","link":"#构建缓存","children":[]}]},{"level":2,"title":"常用构建构建指令","slug":"常用构建构建指令","link":"#常用构建构建指令","children":[]}],"git":{"createdTime":1713261894000,"updatedTime":1713347215000,"contributors":[{"name":"tmh","email":"t13219006372@163.com","commits":2}]},"readingTime":{"minutes":4.66,"words":1399},"filePathRelative":"server/docker/docker-file.md","localizedDate":"2024年4月16日","excerpt":"<h2>什么是 Dockerfile</h2>\\n<p><strong>Dockerfile</strong>是一个用于描述 Docker 镜像构建过程的文本文件，这个文件可以包含多条构建指令以及相关的描述。用户可以自定义 <strong>Dockerfile</strong>构建自己的 docker 镜像。</p>\\n<h2>Docker 镜像的构建原理</h2>\\n<h3>Docker 架构模型</h3>\\n<p>Docker 采用的是<strong>C/S</strong>架构。在客户端使用输入构建命令时，Docker 引擎将命令发送到<strong>docker daemon</strong>，docker daemon 就根据请求内容，开始构建工作，并向 Client 持续返回构建过程信息，让用户可以看到当前的构建状态。</p>"}`);export{u as comp,b as data};
